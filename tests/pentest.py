from unittest import TestCase
import inspect
import penty
import penty.types as pentyping

class TestPenty(TestCase):

    def assertTypesEqual(self, t0, t1):
        st0 = {str(ty) for ty in t0}
        st1 = {str(ty) for ty in t1}
        self.assertEqual(st0, st1)

    def assertIsType(self, expr, ty, env={}):
        if not isinstance(ty, set):
            ty = {ty}
        env = {k: v if isinstance(v, set) else {v}
               for k, v in env.items()}
        self.assertTypesEqual(penty.type_eval(expr, env), ty)


def make_spec_test(name, realobj, value):
    if name == '__init__':
        return None
    def test(self):
        func = value.__args__[0]
        try:
            refargspec = inspect.getfullargspec(getattr(realobj, name))
        except TypeError:
            return
        funcargspec = inspect.getfullargspec(func)
        if name in ('isinstance', 'type'):
            self.assertEqual(refargspec.args,
                             funcargspec.args[:len(refargspec.args)])
        # because we don't perfectly handle class method
        elif name in ('fromkeys'):
            self.assertEqual(refargspec.args[1:],
                             funcargspec.args)
        else:
            self.assertEqual(refargspec.args, funcargspec.args)
    return test


def inject_spec_test(test, obj, realobj, prefix):
    for name, values in penty.penty.Types[obj].items():
        if isinstance(values, set):
            value, = values
        else:
            value = values
        if issubclass(value, pentyping.FunctionType):
            testname = 'test_{}_{}'.format(prefix, name)
            setattr(test, testname, make_spec_test(name, realobj, value))
        elif issubclass(value, pentyping.Type):
            type_ = value.__args__[0]
            inject_spec_test(test, type_, type_, type_.__name__)

